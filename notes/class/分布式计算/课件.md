# 目录
- [0介绍](#0介绍)
- [1分布式计算概述](#1分布式计算概述)
- [2C++预备知识](#2C++预备知识)
- [3从C++到COM](#3从C++到COM)
- [4COM接口](#4COM接口)
- [5COM对象](#5COM对象)
- [6接口的其他实现方法](#6接口的其他实现方法)
- [7重用模型](#7重用模型)
- [8MFC对COM的支持](#8MFC对COM的支持)
- [9ALT对COM的支持](#9ALT对COM的支持)
- [10跨进程特性](#10跨进程特性)
- [11多线程模型](#11多线程模型)
- [12DCOM](#12DCOM)
- [13自动化对象](#13自动化对象)
- [14可连接对象](#14可连接对象)
- [15结构化存储](#15结构化存储)
- [16名字对象](#16名字对象)
- [17统一数据传输](#17统一数据传输)
- [18ActiveX](#18ActiveX)
- [19COM++](#19COM++)
- [20.Net和COM的交互性](#20.Net和COM的交互性)



# 0介绍
略
# 1分布式计算概述
# 2C++预备知识
# 3从C++到COM
## 1.源代码重用
## 2.动态链接库
### 2.1输出类
使用vc.net建立一个动态链接库，输出符号。把FastString的所有方法从DLL中引出去
```c++
//faststring.h
Class __declspec(dllexport)  FastString
{	char * m_psz;
public:
	FastString( char*psz);
	~FastString(void);
	int Length(void);
	int Find( char*psz);
};
//__declspec(dllexport) 是C++编译器指示符, 它通知编译器, 此类的所有成员方法都将对外输出
//FastString的所有方法都将被加载到dll的引出表中。允许在运行时把每个方法的名字解析到内存中对应的地址
```
在vc.net中可以成功调用
```c++
FastString * pf=new FastString("fdfd33");
pf->Length();
```
但是在bc中调用失败，提示，构造函数名字被改变，因此无法成功链接
### 2.2构造函数
为了消除构造函数被改变带来的依赖性，组件输出一个CreateObject函数
```c++
//faststring.h
extern "C" __declspec(dllexport) FastString* CreateObject(char *psz);

//faststring.cpp
FastString* CreateObject(char*psz)
{return new FastString(psz);}
```
客户端代码改为
```c++
FastString * pf=CreateObject("fdfd33");
pf->Length();
```
但是Length函数被名字改编  
为了消除编译器的依赖性。把这些功能函数做成虚函数
### 2.3虚函数
普通函数是解析名字来进行。调用虚函数是根据虚表指针进行的。
```c++
class  __declspec(dllexport) FastString{
	char * m_psz;//保存原始的字符串
public:
	FastString( char*psz);//构造函数
	~FastString(void);
	virtual int  Length(void);//返回该字符串的长度
	virtual int  Find( char*psz);//查找指定的子串
};
extern "C" __declspec(dllexport)FastString* CreateObject(char *psz);
```
### 2.4调用习惯
参数入栈方向：__stdcall从右往左，__cdecl从左往右，多数使用__stdcall
```c++
class  __declspec(dllexport)  FastString{
	char * m_psz;//保存原始的字符串
public:
	FastString( char*psz);//构造函数
	~FastString(void);
	virtual int __stdcall Length(void);//返回该字符串的长度
	virtual int __stdcall Find( char*psz);//查找指定的子串
};
extern "C" __declspec(dllexport)FastString* __stdcall CreateObject(char *psz);
```
所有被bc调用的函数声明为__stdcall
## 3.数据敏感性
略
## 4.接口与实现的分离
降低耦合度，抽象类只描述功能，不涉及实现方法，更不涉及到数据  
接口与实现类的关系
- 定义实现类要实现的公共操作为纯虚函数
- 接口类只包含有方法，没有数据
- 实现类从接口类中派生。实现基类的纯虚函数
- 用户面对接口类来进行各种操作。实现类对用户不可见
服务器端新定义一个类：
```c++
// IFaString.h
class IFastString
{
public:
	IFastString(void);
	~IFastString(void);
	virtual int __stdcall Length(void)=0;//返回该字符串的长度
	virtual int __stdcall Find(char*psz)=0;//查找指定的子串
};
extern "C"__declspec(dllexport) IFastString* __stdcall CreateObject(char *psz);
//改变CreateObject返回值：
```
实现类从接口类派生
```c++
实现类从接口类派生。
//vccom.h
#include ".\IFaststring.h"
class   FastString :public IFastString
{	public:
	char * m_psz;//保存原始的字符串
	FastString(char*psz);//构造函数
     ~FastString(void);
	virtual int __stdcall Length(void);//返回该字符串的长度
	virtual int __stdcall Find(char*psz);//查找指定的子串	
};
//vccom.cpp
IFastString* __stdcall CreateObject(char* psz)
{return new FastString(psz);}
```
实现类对客户端隐藏
```c++
#include "IFastString.h"
void f()
{
	IFastString * pf=CreateObject("fdfd33e");
	cout<<pf->Length ()<<endl;
}
```
不再具有数据敏感性
### 4.1析构函数
对于有继承层次的类，其基类的析构函数一般应定义为虚拟的。否则可能会出现内存泄漏
- 基类和子类可能都需要分配内存
- 为了实现多态的调用，我们一般针对基类指针进行操作
- 使用基类进行删除，只能调用基类的析构
- 子类的内存将无法释放

使用虚拟析构函数则可以避免内存泄漏
- 基类的析构函数声明为虚拟的，这样子类的析构函数也是虚的,并且被改写为释放实现子类分配的内存
- 通过基类指针进行释放时,由于基类指针指向的是子类的对象,所以调用的是子类的析构函数

子类的析构函数的执行顺序为
1. 子类本身的析构函数
2. 对象成员的析构函数
3. 基类的析构函数

因此派生类析构函数将递归地激活基类的析构函数.通过这样的方法可以完整地释放派生类对象所占用的存储空间
```c++
class  __declspec(dllexport) 
   IFastString
{
public:
	IFastString(void);
	virtual ~IFastString(void);
	virtual int __stdcall Length(void)=0;//返回该字符串的长度
	virtual int __stdcall Find(char*psz)=0;//查找指定的子串
};
```
vc客户端内存泄漏消失
### 4.2虚析构函数
但是以上代码在bc客户端会再次发生链接失败  
原因：因为虚析构函数在虚表中的位置随着编译器的不同而不同。使用A编译器编译出来的DLL中的对象,在B编译器中使用一个指向此对象的指针去调用其虚的析构函数时, 由于两种编译器对于虚析构函数的位置的理解不一致, B编译器不能在预期的位置找到析构函数,因此仍然会造成链接失败  
因此，仿照CreateObject去代替构造函数的方法，给类添加一个Delete函数，在Delete函数中删除对象
```c++
class IFastString
{
public: 
    virtual void Delete()=0;
    virtual int _stdcall Length(void)=0;
    virtual int _stdcall Find( char*psz)=0;	   	  
};
//子类
class   FastString：public IFastString
{
	char * m_psz;//保存原始的字符串	
public:
	FastString( char*psz);//构造函数
     ~FastString(void);
	virtual void __stdcall Delete(void);
     virtual int __stdcall Length(void);//返回该字符串的长度
	virtual int __stdcall Find( char*psz);//查找指定的子串
};
//Delete实现
void FastString::Delete ()
{delete this;}
```
Dll的四个文件：接口类的声明和实现，实现类的声明和实现，只有接口类的声明需要提供给客户。  
Dll只引出一个函数CreateObject  

客户的使用方法(bc下)  
静态加载，项目加入FaseString.lib引入文件
```c++
#include "IFastString.h"//客户需要接口类的声明文件.
IFastString *pIFS=CreateObject("abcd");//创建一个实现类的实例,用一个接口类的指针指向它.
pIFS->Find("a");//通过接口类来调用实现类的功能
pIFS->Delete();//释放内存
```
动态加载
```c++
IFastString *pIF;
HANDLE h;
h=LoadLibrary("FastString.dll");
if(h==NULL){ShowMessage("load err");return;}
typedef IFastString *(__stdcall *PF)(char *);
PF pf;
pf=(PF)GetProcAddress(h,"CreateObject");
pIF= pf("abcd");//或pIF=(*pf)(“abcd”);
pIF ->Length();//……使用接口
pIF->Find(“a”);
pIF->Delete();
FreeLibrary(h);
```
## 5.对象的扩展性
### 5.1功能扩展的需求
在接口类定义不变的情况下,实现者可以自由地对实现方案进行升级，客户无需重新编译  
但如果需要扩展功能，该如何解决呢？这里的问题指的是新老客户共存，老客户使用新对象没问题，但新客户使用老对象会出现问题  
有两种途径：
- 设计一个接口使得它继承自另一个相关的接口
- 让实现类继承多个不相关的接口
### 5.2方法一：扩展接口
```c++
//对原接口进行扩展,生成新的接口.比如使用从原接口继承的方式
class FastString : public IFastString2
{	int m_cch;
	char*m_psz;
public:
	FastString( char* psz);
	~FastString();
	void __stdcall Delete(void); //IFastString的方法
	int __stdcall Length(void); 
	int __stdcall Find( char*psz);
    int __stdcall FindN(char*psz,int n);//IFastString2的方法，实现类提供它的实现。 其他的方法同前
};
//客户在运行时询问对象，以确认对象是狗支持新的接口，这里将使用dynamic_cast运算符
int Find10thBob(IFastString *pfs)
{
    IFastString2 *pfs2=dynamic_cast<IFastString2 *>(pfs);
    if(pfs2)return pfs2->FindN("Bob",10);
    //如果实现了IFastString2 接口. 新实现类(如果使用的是新的服务器)
    else error("can not find 10th occurrence of Bob");
    //如果实现了IFastString2 接口. 老实现类(如果使用的是老的服务器)
}
```
### 5.3方法二：多接口
前一节新接口扩展的功能与原功能有一定的逻辑关系  
当对象需要提供不相关的新功能时，让新接口继承原接口不可行，因为其他接口可能也需要新接口的功能，但不需要原接口中的功能  
为了使新接口具有通用性，它应该是一个独立的接口
```c++
class IPersistentObject{
public:
    virtual void __stdcall Delete()=0;//使对象能够删除自身
    virtual bool __stdcall Load( char *pszFileName)=0;//实际功能
    virtual bool __stdcall Save( char *pszFileName)=0;
}
//实现类要继承两个接口
class FastString:public IFastString, public IPersistentObject
{	int m_cch;
    char*m_psz;
public:
    FastString( char* psz);
    ~FastString();
    void __stdcall Delete(void); //虚表中有两项,同时改写
    int __stdcall Length(void);//IFastString的方法
    int __stdcall Find( char*psz);
    bool __stdcall Load( char *pszFileName);//IPersistentObject的方法
    bool __stdcall Save( char *pszFileName);
};
//假如客户得到了IFastString指针，如果客户想要操作IPersistentObject提供的功能，只需要使用RTTI得到一个指向对象暴露出来的IPersistentObject接口即可：
bool SaveString（IFastString*pfs,char *pszFN)
{   bool bResult=false;
    IPersistentObject *ppo=dynamic_cast<IPersistentObject*>(pfs);//此处是cross cast
    if(ppo) {
        bResult=ppo->Save(pszFN);//如果是新对象
        return bResult;
    }
    else …  //如果是老对象
}
```
### 5.4中性的类型转换
以上的升级过程完全依赖于RTTI，服务器和客户端必须同时启动RTTI  
但每个编译器厂商对于RTTI的实现是不相同的，这破坏了以抽象基类作为接口而获得的编译器的独立性  
我们可以中性地处理dynamic_cast的语义，不使用与编译器相关的语言特征。从每个接口显示地暴露出一个广为人知的方法，来完成与dynamic_cast语义等价的功能
```c++
class IPersistentObject{
public:
    virtual void * __stdcall Dynamic_cast( char*pszType)=0;//注意Dynamic_cast是一个函数而不是操作符
    virtual void __stdcall Delete()=0;//删除操作
    virtual bool __stdcall Load( char *pszFileName)=0;//功能
    virtual bool __stdcall Save( char *pszFileName)=0;}
class IFastString{
public:
    virtual void * __stdcall Dynamic_cast( char*pszType)=0;
    virtual void __stdcall Delete()=0;
    virtual int __stdcall Length()=0;
    virtual int __stdcall Find( char*psz)=0;}

//这两个接口都提供了dynamic_cast和delete方法，可以提升到一个基类中
class IExtensibleObject{  //实现通用的功能
public:
    virtual void * __stdcall Dynamic_cast( char*pszType)=0;//转换
    virtual void __stdcall Delete()=0;}//删除
class IPersistentObject:public IExtensibleObject{
public://实际功能
    virtual bool __stdcall Load( char *pszFileName)=0;
    virtual bool __stdcall Save( char *pszFileName)=0;}
class IFastString:public IExtensibleObject{
public:  //实际功能
    virtual int __stdcall Length()=0;
    virtual int __stdcall Find( char*psz)=0;}

//实现类的定义
class FastString : public IFastString  ,public IPersistentObject
{	int m_cch;
	char*m_psz;
public:
	FastString( char* psz);
	~FastString(); 
    void * __stdcall Dynamic_cast( char*pszType)//一般的方法	
    void __stdcall Delete(void);
	int __stdcall Length(void);//IFastString的方法
	int __stdcall Find(char*psz);
    bool __stdcall Load(char *pszFileName);//IPersistentObject的方法
    bool __stdcall Save(char *pszFileName);
};
```
可以使用显示的静态转换，将this指针转换到客户所请求的类型
```c++
void *FastString::Dynamic_Cast(char *pszType){
    if(strcmp(pszType,"IFastString")==0)
        return static_cast<IFastString*>(this);
    else if(strcmp(pszType,"IPersistentObject")==0)
        return static_cast<IPersistentObject*>(this);
    else if(strcmp(pszType,"IExtensibleObject")==0)
        return static_cast<IFastString*>(this);
    return 0;}//未支持接口的请求。
```
static_cast仅仅是在对象与子对象之间进行偏移的加减.是编译器中性的。  dynamic_cast要改变虚表指针所指向虚表的可见部分,其实现方式是编译器相关的  
客户的使用方式
```c++
IFastString *pfs;
IPersistentObject *ppo;
pfs=CreateObject("asdf");//创建对象。
pfs->Find("a");//使用老接口
ppo=(IPersistentObject*) pfs->Dynamic_Cast("IPersistentObject");//编译器中性的转换
if(ppo!=NULL)ppo->Save("c:\\myfile");//使用新接口
pfs->Delete();//使用pfs来删除对象。
```
优点:通过中性的转换得到另一个接口,再一次消除编译器依赖性  
缺点:对象的创建和释放过程存在安全隐患
## 6资源管理
上节提到的指针转换，实际上两个指针指向额是同一个对象，分别通过两个指针调用Delete是等价的。其中一个指针调用Delete将会引起另一指针的失效  
对同一个对象只能调用一次Delete，且必须调用一次  
缺点：
- 指针没有独立的生命周期
- 指针之间的过渡耦合
- 客户看不见的对象决定了指针的生命

必须割裂指针之间的高度耦合，让指针具有独立的生命周期，实现的方法就是：


每个对象维护一个引用计数，当接口指针被复制的时候，计数增加；接口指针被销毁的时候，计数减少
```c++
class IExtensibleObject{
public:
    virtual void * __stdcall Dynamic_cast( char*pszType)=0;
    virtual void __stdcall Delete()=0;  }
//改进为：
class IExtensibleObject{
public:
    virtual void * __stdcall Dynamic_cast( char*pszType)=0;
    virtual void __stdcall DuplicatePointer(void)=0;
    virtual void __stdcall DestroyPointer(void)=0;
}

class FastString:public IFastString ,public IPersistentObject
{	int m_cPtrs;//引用指针数目
	......
public:
	FastString(char* psz):m_cPtrs(0){};//引用指针数目初始化为0；
	void DuplicatePointer(void){ ++m_cPtrs;}//增加引用计数
    void DestroyPointer(void){if(--m_cPtrs==0) delete this;} //减少引用计数,减到0时,删除对象自身
    ......};

//CreateObject函数
IFastString *CreateObject( char*psz){ 
    IFastString *pFS=new FastString(psz);
    if(pFS) pFS->DuplicatePointer();
    return new pFS;}
//Dynamic_Cast函数
void *FastString::Dynamic_Cast( char *pszType){
    void* pv=0;
    if(strcmp(pszType,"IFastString")==0)
        pv=static_cast<IFastString*>(this);
    else if(strcmp(pszType,"IPersistentObject")==0)
        pv= static_cast<IPersistentObject*>(this);
    else if(strcmp(pszType,"IExtensibleObject")==0)
        pv= static_cast<IFastString*>(this);
    else return 0;//未支持接口的请求。
    pv->DuplicatePointer();  // 引用计数加1
    return pv;
}

//当接口指针被复制时，调用DuplicatePointer。（服务器自动调用）
//当接口指针被销毁时，调用DestroyPointer（客户端主动调用）
IFastString *pfs;IPersistentObject *ppo;
pfs=CreateObject("asdf");//ref=1
if(pfs){
    pfs->Find("a"); 
    ppo=(IPersistentObject*)pfs->Dynamic_Cast("IPersistentObject");//ref=2 
    if(ppo){
        ppo->Save("c:\\myfile");
        ppo->DestroyPointer();
    }//销毁ppo  ref=1
    pfs->DestroyPointer();//销毁pfs  ref=0 对象销毁
}//每个指针各自负责自己的引用计数操作。
```

# 4COM接口
## 1.接口的结构与描述
COM把接口与实现分离开的动机
> 把对象内部的工作细节对客户隐藏起来。使得实现类内部的数据成员的数量、类型以及内部的方法都可以发生变化，而客户程序无需重新编译

COM规范规定
### 1.1C++,C,Delphi
### 1.2IDL
### 1.3接口的标识
### 1.4方法与结果
### 1.5数据类型
### 1.6MIDL编译器
## 2.IUnknown接口
### 2.1IUnknown接口定义
### 2.2引用计数规则
### 2.3接口查询规则
# 5COM对象
# 6接口的其他实现方法
# 7重用模型
# 8MFC对COM的支持
# 9ALT对COM的支持
# 10跨进程特性
# 11多线程模型
# 12DCOM
# 13自动化对象
# 14可连接对象
# 15结构化存储
# 16名字对象
# 17统一数据传输
# 18ActiveX
# 19COM++
# 20.Net和COM的交互性